[{"title":"子集和问题","date":"2018-01-17T08:18:37.000Z","path":"2018/01/17/子集和问题/","text":"各种类型的子集和问题一、子集和的种类问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于给定的集合和给定的一个和sum，从集合中选取元素得到子集，使得子集的和等于给定的sum，求有多少种组合的方式。思路解析：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此种问题与找币问题一样。采用动态规划的方式解决这一问题。对于每个集合中元素，都有两种方式：选择和不选择。用dp[i]表示子集和为i的组合个数，可知dp[0]为1，因此子集和为0的子集只有空集一个。核心代码：void dfs(int n,int sum){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp;dp(sum+1,0); //初始都为0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;i,j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[0]=1; //子集和为0的时候组合为1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n;i++) //集合中每个元素有选择和不选择两种方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=sum;j&gt;=v[i];j++) //内层循环应该是从sum开始递减到v[i],这样确保集合中元素只使用一次；如果从v[i]递增到sum，那么集合中的每个元素可以使用无限多个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[j]+=dp[j-v[i]]; //选择v[i]和不选择v[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;dp[sum]&lt;&lt;endl;}二、列出子集和的各种方案：问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于给定的集合和给定的一个和sum，从集合中选取元素得到子集，使得子集的和等于给定的sum，打印每个符合要求的子集。思路解析：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里采用回溯+递归的方式，采用一个容器保存原始的集合，一个容器保存结果集合。对于原始集合，如果集合中的元素&lt;=sum时，将集合中的元素放入到结果集合，当添加后的的子集和大于预定的值时，那么此时将最后一个添加的踢出结果集合，并继续迭代。核心代码：void dfs(int n, int sum, vector&lt;int&gt;&amp; v, int start) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sum == 0) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i&lt;v.size(); i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i == 0 ? cout &lt;&lt; v[i] : cout &lt;&lt; “ “ &lt;&lt; v[i]; //i等于0输出v[i],否则先输出空格，后输出v[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = start; i &lt;= n &amp;&amp; origin[i] &lt;= sum; i++) { //首先满足下标不越界，同时所选的子集中的元素应该小于等于sum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(origin[i]); //选定一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(n, sum - origin[i], v, i + 1); //通过sum-origin[i]来进一步的判定这个元素是否可选，如果当它的结果小于0时，它就不满足for循环中的循环条件，就会回退&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.pop_back(); //踢出不符合的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}三、打印子集个数确定的子集和方案：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与问题二相似，但是需要确保每种子集和的子集中元素个数为给定的个数void dfs(int n, int sum, vector&lt;int&gt;&amp; v, int start) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sum == 0 &amp;&amp; v.size()==count_num) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i&lt;v.size(); i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i == 0 ? cout &lt;&lt; v[i] : cout &lt;&lt; “ “ &lt;&lt; v[i]; //i等于0输出v[i],否则先输出空格，后输出v[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = start; i &lt;= n &amp;&amp; origin[i] &lt;= sum; i++) { //首先满足下标不越界，同时所选的子集中的元素应该小于等于sum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(origin[i]); //选定一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(n, sum - origin[i], v, i + 1); //通过sum-origin[i]来进一步的判定这个元素是否可选，如果当它的结果小于0时，它就不满足for循环中的循环条件，就会回退&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.pop_back(); //踢出不符合的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}","comments":true,"tags":[]},{"title":"迷宫问题","date":"2018-01-16T15:07:58.000Z","path":"2018/01/16/迷宫问题/","text":"回溯法解决迷宫问题一、问题描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个迷宫，如果能够走出这个迷宫，那就寻找一条走出这个迷宫的最短路径，否则不能走出这个迷宫。迷宫是一个方形体，起点为迷宫的左上角，终点为迷宫的右下角。每次都可以往四个不同的方向走，但是不能超过这个迷宫的范围。如果在行走的过程中遇到了障碍物，那么这个方向将不能继续行进，此时将需要选择其它方向。二、思路解析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;迷宫中1表示有路可走，0表示有障碍物。行走的方向可以是上下左右，用一个二维的容器存放迷宫(0,1，其中0表示障碍物，1表示路段可走)；用一个一维容器存放临时的可行方案；用一个一维容器存放最佳的可行方案。每次遇到一个可行方案的时候，将这个可行的方案与最佳的方案对比，如果这个可行的方案比最佳的方案好，那么就将这个可行的方案拷贝给这个最佳的方案。而每个方案的形成需要返回的试探，如果这个方向没有障碍物，那么就走这个方向，否则回退到上一步，并从新选择其它的方向。每次选中一个可行的路径，将这个路径的坐标放进临时容器，回退的时候(也就是此路不通)，将这个坐标踢出这个临时容器。直到坐标到达迷宫的右下角。这里会有一个问题，那就是行走的过程中可能会形成一个环，这就会导致永远也走不出这个迷宫的出口。为了解决这个问题，这里给出的解决方案是每次选择一个可行的行走路径时，将其设置为障碍点，而每次回退的时候，将它恢复为原来的状态。这样就可以避免环形路径。三、核心代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void backtrace(int x,int y) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mate[x][y] = 0; //走的路将不再重复去走&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp_path.push_back({ x,y });&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(x==M-1 &amp;&amp; y==N-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (best_path.empty() || tmp_path.size() &lt; best_path.size())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_path = tmp_path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x - 1 &gt;= 0 &amp;&amp; mate[x - 1][y] == 1) //向上走&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrace(x - 1, y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x + 1 &lt; M &amp;&amp; mate[x + 1][y] == 1) //向下走&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrace(x + 1, y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (y - 1 &gt;= 0 &amp;&amp; mate[x][y - 1] == 1) //向左走&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrace(x, y - 1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (y + 1 &lt; N &amp;&amp; mate[x][y + 1] == 1) //向右走&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrace(x, y + 1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mate[x][y] = 1; //恢复现场&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp_path.pop_back(); //弹出不能走的结点}四、结果截图五、完整源码地址：https://github.com/dingwenjin/C-/blob/master/mate.cpp","comments":true,"tags":[]},{"title":"用户自定义unordered_map的key值","date":"2018-01-14T02:11:49.000Z","path":"2018/01/14/用户自定义unordered-map的key值/","text":"解决一个域不唯一标识一个数据节点问题本节的重点主要是讲解unordered_map中用户自定义key值的问题。一、unordered_map介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unordered_map是C++中一个重要的数据结构，它是以键值对(key-value)的方式存储数据项(key值时唯一的)，通过对key值计算hash得到一个唯一的密钥；每次查找key值所在的数据项时，就对待查找的key进行hash得到一个密钥，然后与容器中每个key的密钥对比，要是能找到这个密钥，说明这两个key值是一样的，也就是说这个数据项存在容器中。因此它的查找速度非常快，可以达到常数级别。二、问题的引入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在模拟客户端-服务器数据访问时，想测试一下不同替换算法的命中率情况。于是在论文中找到了一个网址，并下载了很多trace。这些trace都是用户的真实访问情况。这个trace包括这几个数据域：文件名、数据块的逻辑地址、数据块大小、访问属性(读/写)和时间戳。trace显示的情况来看，数据是随机访问的。由于一个trace文件有几百万条记录。考虑到检索的速度，于是使用unordered_map这个结构。它可以有效的减少数据的检索时间。但是单一的文件名或者数据块的逻辑地址是不能唯一确定这个文件的数据块是否存在的。因此默认的常规key就不适合这种情况(常规的key只有一个域就可以唯一确定一个记录)。因此想着自定义一个key，它是一个结构类型，包括多个域。三、思路&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先自定义key，这个类型是一个结构类型。然后再定义一个hash函数，主要是计算每个key的hash值。然后定义一个比较函数，这个比较函数是一个仿函数。主要的功能是判定两个key的各个数据域是否相等。相等返回真，不相等返回假。最后定义容器。主要结构如下：struct IO_Record { //value的域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t Size; //逻辑块大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint16_t hit_count; //命中率};struct Link_Node { //key的域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint16_t ASU; //文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t LBA; //文件的逻辑块地址};struct HashFunc { //hash函数，对自定义的key值进行加密，这里使用或和移位操作可以降低hash冲突的概率&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t operator()(const Link_Node &amp;key) const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using std::size_t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using std::hash;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hash()(key.ASU) ^ hash()(key.LBA) &lt;&lt; 1)) &gt;&gt; 1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}};struct cmp { //这是一个比较函数，用于比较key是否一样&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool operator()(const Link_Node &amp;n1, const Link_Node &amp;n2) const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return n1.ASU == n2.ASU &amp;&amp; n1.LBA == n2.LBA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}};unordered_map&lt;Link_Node, IO_Record*, HashFunc, cmp&gt;&nbsp;&nbsp;&nbsp;&nbsp;check_request; //定义一个容器四、结果截图五、源码分享&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完整的程序已经上传到github上了，如果有需要的同志，可以自行下载：https://github.com/dingwenjin/C-/blob/master/unordered_map.cpp","comments":true,"tags":[]},{"title":"最长公共子序列","date":"2018-01-03T11:28:30.000Z","path":"2018/01/03/最长公共子序列/","text":"来源：牛客网链接：https://www.nowcoder.com/questionTerminal/b1112516673e463c9ed8943ae96e53f6给出两个字符串（可能包含空格）,找出其中最长的公共连续子串,输出其长度。输入描述:输入为两行字符串（可能包含空格），长度均小于等于50.输出描述:输出为一个整数，表示最长公共连续子串的长度。示例：输入abcdeabgde输出2解题思想：&nbsp;&nbsp;&nbsp;&nbsp;创建一张二维表，本来这张表是用来存储字符A[i]和B[j]是否相等然后将表中(i,j)位置置为1。遍历结束后，计算所有的对角线上连续1的个数，取最大值就是结果。但是现在，换种方法，遍历的同时，计算当前斜对角的值，然后用一个变量res记录最大的值即可。&nbsp;&nbsp;&nbsp;&nbsp;它的公式为：如果A[i - 1] == B[j - 1]，那么dp[i][j] = dp[i - 1][j - 1] + 1;其中dp[0][…]和dp[…][0]都是0，这是初始状态。例子：字符串A：abcde字符串B：abgde表11 0 0 0 00 1 0 0 00 0 0 0 00 0 0 1 00 0 0 0 1这个不可以直接得到结果，需要再遍历一次计算。表20 0 0 0 0 00 1 0 0 0 00 0 2 0 0 00 0 0 0 0 00 0 0 0 1 00 0 0 0 0 2这个可以直接得到结果，不需要再遍历一次计算。#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void deal(string s1, string s2) {&nbsp;&nbsp;&nbsp;&nbsp;int i, j, len1 = s1.size(), len2 = s2.size(), max_len = 0;&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;vector&lt;int&gt; &gt; dp(len1+1,vector&lt;int&gt;(len2+1,0));&nbsp;&nbsp;&nbsp;&nbsp;for (i = 1; i &lt;= len1; i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j = 1; j &lt;= len2; j++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s1[i - 1] == s2[j - 1])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j] = dp[i - 1][j - 1] + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (dp[i][j] &gt; max_len)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_len = dp[i][j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; max_len &lt;&lt; endl;}int main() {&nbsp;&nbsp;&nbsp;&nbsp;string s1, s2;&nbsp;&nbsp;&nbsp;&nbsp;while (getline(cin, s1)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getline(cin, s2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deal(s1, s2);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;system(“pause”);&nbsp;&nbsp;&nbsp;&nbsp;return 0;}","comments":true,"tags":[]},{"title":"一棵开花的树","date":"2018-01-03T06:32:37.000Z","path":"2018/01/03/一棵开花的树/","text":"作者：席慕容如何让你遇见我在我最美丽的时刻为这我已在佛前求了五百年求佛让我们结一段尘缘佛於是把我化做一棵树长在你必经的路旁阳光下慎重地开满了花朵朵都是我前世的盼望当你走近请你细听那颤抖的叶是我等待的热情而当你终於无视地走过在你身後落了一地的朋友啊那不是花瓣那是我凋零的心","comments":true,"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux下多个C-文件链接编译","date":"2018-01-01T15:20:24.000Z","path":"2018/01/01/Linux下多个C-文件链接编译/","text":"一、首先在C++文件中创建两个文件夹，一个是myinclude，另一个是src。这里是大数相乘的程序，myinclude中是头文件(仅包含程序体)和它的源文件(实现部分)，src包含主函数。整体的目录结构如下：Myinclude下的头文件如下：/**&gt; File Name: big_data_multi.h &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:42:10 PM PST **/#ifndef _BIG_DATA_MULTI_HEAD_H#define _BIG_DATA_MULTI_HEAD_H#include &lt;string&gt;using std::string;void big_data_multi(string,string);#endifMyinclude下的源文件如下：/*&gt; File Name: big_data_multi.cpp &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:44:38 PM PST **/#include &quot;big_data_multi_head.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;void big_data_multi(string s1,string s2) {&nbsp;&nbsp;&nbsp;&nbsp;int len1=s1.size(),len2=s2.size(),i,j,carry=0;&nbsp;&nbsp;&nbsp;&nbsp;string result(len1+len2,’0’);&nbsp;&nbsp;&nbsp;&nbsp;reverse(s1.begin(),s1.end());&nbsp;&nbsp;&nbsp;&nbsp;reverse(s2.begin(),s2.end());&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;len1;i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;len2;j++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carry=(s1[i]-‘0’)*(s2[j]-‘0’)+result[i+j]-‘0’;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[i+j]=carry%10+’0’;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carry/=10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(carry)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[i+len2]=carry%10+’0’;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carry=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverse(result.begin(),result.end());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(result[0]==’0’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;result.substr(1)&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;result&lt;&lt;endl;}src目录下的主文件内容如下：/*&gt; File Name: big_data_multi.cpp &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:44:38 PM PST **/#include &quot;../myinclude/big_data_multi_head.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using std::string;using std::cin;int main(int argc,char** argv){&nbsp;&nbsp;&nbsp;&nbsp;string s1,s2;&nbsp;&nbsp;&nbsp;&nbsp;while(cin&gt;&gt;s1&gt;&gt;s2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;big_data_multi(s1,s2);&nbsp;&nbsp;&nbsp;&nbsp;return 0;}方式一：编译的过程如下：&nbsp;&nbsp;首先对big_data_multi_head.cpp文件进行编译，因为不事先编译这个文件，而直接编译主文件的话就会出错，出错原因是没有找到主文件调用的函数体。编译后的结果如下：&nbsp;&nbsp;然后对主文件进行编译，形成可执行的main文件：&nbsp;&nbsp;最后执行main文件：方式二：编译的过程如下：&nbsp;&nbsp;首先对big_data_multi_head.cpp文件进行编译，因为不事先编译这个文件，而直接编译主文件的话就会出错，出错原因是没有找到主文件调用的函数体。编译后的结果如下：&nbsp;&nbsp;然后对主文件进行编译，形成可执行的main文件：&nbsp;&nbsp;最后执行main文件：","comments":true,"tags":[]},{"title":"Python 置筛子结果","date":"2018-01-01T13:32:05.000Z","path":"2018/01/01/Python-置筛子结果/","text":"python程序模拟置筛子结果import pygalfrom random import randintfrom pylab import *mpl.rcParams[‘font.sans-serif’] = [‘SimHei’] #解决中文字体class Die():&nbsp;&nbsp;&nbsp;&nbsp;def init(self,num_sides=6):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.num_sides = num_sides&nbsp;&nbsp;&nbsp;&nbsp;def roll(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return randint(1,self.num_sides+1)def rolling_result(die):&nbsp;&nbsp;&nbsp;&nbsp;results = []&nbsp;&nbsp;&nbsp;&nbsp;for roll_num in range(100000):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = die.roll()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results.append(result)&nbsp;&nbsp;&nbsp;&nbsp;return resultsdef sides_frequency(die,results):&nbsp;&nbsp;&nbsp;&nbsp;frequencies = []&nbsp;&nbsp;&nbsp;&nbsp;for value in range(1,die.num_sides+1):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frequency = results.count(value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frequencies.append(frequency)&nbsp;&nbsp;&nbsp;&nbsp;return frequenciesdef drawing(frequencies):&nbsp;&nbsp;&nbsp;&nbsp;hlist = pygal.Bar()&nbsp;&nbsp;&nbsp;&nbsp;hlist.title = “置骰子10万次各个点数频率分布结果图”&nbsp;&nbsp;&nbsp;&nbsp;hlist.x_labels = [‘1’,’2’,’3’,’4’,’5’,’6’]&nbsp;&nbsp;&nbsp;&nbsp;hlist.x_title = “骰子的各个点数”&nbsp;&nbsp;&nbsp;&nbsp;hlist.y_title = “频率分布”&nbsp;&nbsp;&nbsp;&nbsp;hlist.add(‘D6’,frequencies)&nbsp;&nbsp;&nbsp;&nbsp;hlist.render_to_file(‘die_visual_svg’) #生成def main():&nbsp;&nbsp;&nbsp;&nbsp;die = Die()&nbsp;&nbsp;&nbsp;&nbsp;results = rolling_result(die)&nbsp;&nbsp;&nbsp;&nbsp;frequencies = sides_frequency(die,results)&nbsp;&nbsp;&nbsp;&nbsp;drawing(frequencies)if name == ‘main‘:&nbsp;&nbsp;&nbsp;&nbsp;main()","comments":true,"tags":[]}]