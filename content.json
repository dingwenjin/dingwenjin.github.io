[{"title":"最长公共子序列","date":"2018-01-03T11:28:30.000Z","path":"2018/01/03/最长公共子序列/","text":"来源：牛客网链接：https://www.nowcoder.com/questionTerminal/b1112516673e463c9ed8943ae96e53f6 给出两个字符串（可能包含空格）,找出其中最长的公共连续子串,输出其长度。输入描述:输入为两行字符串（可能包含空格），长度均小于等于50. 输出描述:输出为一个整数，表示最长公共连续子串的长度。示例1输入abcdeabgde输出2 解题思想： DP问题，利用空间换时间，时间复杂度O(NM),空间O(NM)思想：创建一张二维表，本来这张表是用来存储字符A[i]和B[j]是否相等然后将表中(i,j)位置置为1。遍历结束后，计算所有的对角线上连续1的个数，取最大值就是结果。但是现在，换种方法，遍历的同时，计算当前斜对角的值，然后用一个变量res记录最大的值即可。它的公式为：如果A[i - 1] == B[j - 1]，那么dp[i][j] = dp[i - 1][j - 1] + 1;其中dp[0][…]和dp[…][0]都是0，这是初始状态。例子：字符串A：abcde字符串B：abgde表11 0 0 0 00 1 0 0 00 0 0 0 00 0 0 1 00 0 0 0 1这个不可以直接得到结果，需要再遍历一次计算。表20 0 0 0 0 00 1 0 0 0 00 0 2 0 0 00 0 0 0 0 00 0 0 0 1 00 0 0 0 0 2这个可以直接得到结果，不需要再遍历一次计算。 #include #include #include #includeusing namespace std; void deal(string s1, string s2) { int i, j, len1 = s1.size(), len2 = s2.size(), max_len = 0; vector","comments":true,"tags":[]},{"title":"一棵开花的树","date":"2018-01-03T06:32:37.000Z","path":"2018/01/03/一棵开花的树/","text":"作者：席慕容如何让你遇见我在我最美丽的时刻为这我已在佛前求了五百年求佛让我们结一段尘缘佛於是把我化做一棵树长在你必经的路旁阳光下慎重地开满了花朵朵都是我前世的盼望当你走近请你细听那颤抖的叶是我等待的热情而当你终於无视地走过在你身後落了一地的朋友啊那不是花瓣那是我凋零的心","comments":true,"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux下多个C-文件链接编译","date":"2018-01-01T15:20:24.000Z","path":"2018/01/01/Linux下多个C-文件链接编译/","text":"一、首先在C++文件中创建两个文件夹，一个是myinclude，另一个是src。这里是大数相乘的程序，myinclude中是头文件(仅包含程序体)和它的源文件(实现部分)，src包含主函数。整体的目录结构如下： Myinclude下的头文件如下：/** &gt; File Name: big_data_multi.h &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:42:10 PM PST **/ #ifndef _BIG_DATA_MULTI_HEAD_H #define _BIG_DATA_MULTI_HEAD_H #include &lt;string&gt;using std::string;void big_data_multi(string,string); #endif Myinclude下的源文件如下：/* &gt; File Name: big_data_multi.cpp &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:44:38 PM PST **/ #include &quot;big_data_multi_head.h&quot; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt;using namespace std; void big_data_multi(string s1,string s2) {&nbsp;&nbsp;&nbsp;&nbsp;int len1=s1.size(),len2=s2.size(),i,j,carry=0;&nbsp;&nbsp;&nbsp;&nbsp;string result(len1+len2,’0’);&nbsp;&nbsp;&nbsp;&nbsp;reverse(s1.begin(),s1.end());&nbsp;&nbsp;&nbsp;&nbsp;reverse(s2.begin(),s2.end());&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;len1;i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;len2;j++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carry=(s1[i]-‘0’)*(s2[j]-‘0’)+result[i+j]-‘0’;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[i+j]=carry%10+’0’;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carry/=10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(carry)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[i+len2]=carry%10+’0’;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carry=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverse(result.begin(),result.end());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(result[0]==’0’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;result.substr(1)&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;result&lt;&lt;endl;} src目录下的主文件内容如下：/* &gt; File Name: big_data_multi.cpp &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:44:38 PM PST **/ #include &quot;../myinclude/big_data_multi_head.h&quot; #include &lt;iostream&gt; #include &lt;string&gt;using std::string;using std::cin; int main(int argc,char** argv){&nbsp;&nbsp;&nbsp;&nbsp;string s1,s2;&nbsp;&nbsp;&nbsp;&nbsp;while(cin&gt;&gt;s1&gt;&gt;s2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;big_data_multi(s1,s2);&nbsp;&nbsp;&nbsp;&nbsp;return 0;} 方式一：编译的过程如下：&nbsp;&nbsp;首先对big_data_multi_head.cpp文件进行编译，因为不事先编译这个文件，而直接编译主文件的话就会出错，出错原因是没有找到主文件调用的函数体。编译后的结果如下： &nbsp;&nbsp;然后对主文件进行编译，形成可执行的main文件： &nbsp;&nbsp;最后执行main文件： 方式二：编译的过程如下：&nbsp;&nbsp;首先对big_data_multi_head.cpp文件进行编译，因为不事先编译这个文件，而直接编译主文件的话就会出错，出错原因是没有找到主文件调用的函数体。编译后的结果如下： &nbsp;&nbsp;然后对主文件进行编译，形成可执行的main文件： &nbsp;&nbsp;最后执行main文件：","comments":true,"tags":[]},{"title":"Python 置筛子结果","date":"2018-01-01T13:32:05.000Z","path":"2018/01/01/Python-置筛子结果/","text":"python程序模拟置筛子结果import pygalfrom random import randintfrom pylab import *mpl.rcParams[‘font.sans-serif’] = [‘SimHei’] #解决中文字体 class Die():&nbsp;&nbsp;&nbsp;&nbsp;def init(self,num_sides=6):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.num_sides = num_sides&nbsp;&nbsp;&nbsp;&nbsp;def roll(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return randint(1,self.num_sides+1) def rolling_result(die):&nbsp;&nbsp;&nbsp;&nbsp;results = []&nbsp;&nbsp;&nbsp;&nbsp;for roll_num in range(100000):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = die.roll()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results.append(result)&nbsp;&nbsp;&nbsp;&nbsp;return results def sides_frequency(die,results):&nbsp;&nbsp;&nbsp;&nbsp;frequencies = []&nbsp;&nbsp;&nbsp;&nbsp;for value in range(1,die.num_sides+1):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frequency = results.count(value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frequencies.append(frequency)&nbsp;&nbsp;&nbsp;&nbsp;return frequencies def drawing(frequencies):&nbsp;&nbsp;&nbsp;&nbsp;hlist = pygal.Bar()&nbsp;&nbsp;&nbsp;&nbsp;hlist.title = “置骰子10万次各个点数频率分布结果图”&nbsp;&nbsp;&nbsp;&nbsp;hlist.x_labels = [‘1’,’2’,’3’,’4’,’5’,’6’]&nbsp;&nbsp;&nbsp;&nbsp;hlist.x_title = “骰子的各个点数”&nbsp;&nbsp;&nbsp;&nbsp;hlist.y_title = “频率分布”&nbsp;&nbsp;&nbsp;&nbsp;hlist.add(‘D6’,frequencies)&nbsp;&nbsp;&nbsp;&nbsp;hlist.render_to_file(‘die_visual_svg’) #生成 def main():&nbsp;&nbsp;&nbsp;&nbsp;die = Die()&nbsp;&nbsp;&nbsp;&nbsp;results = rolling_result(die)&nbsp;&nbsp;&nbsp;&nbsp;frequencies = sides_frequency(die,results)&nbsp;&nbsp;&nbsp;&nbsp;drawing(frequencies) if name == ‘main‘:&nbsp;&nbsp;&nbsp;&nbsp;main()","comments":true,"tags":[]}]