[{"title":"利用github搭建个人博客","date":"2018-09-09T06:34:21.000Z","path":"2018/09/09/利用github搭建个人博客/","text":"github pages搭建个人博客一、准备工作：(1)在github上注册一个账户(2)在本地上安装一个git客户端(3)在本地上安装node.js客户端二、环境的搭建(1)在GitHub上注册账户，在这里就不多累赘了。要是新手不会的话可以去网上找，教程很多。(2)安装git客户端，下载地址：https://git-scm.com/downloads(3)安装node.js客户端，下载地址：https://nodejs.org/en/download/安装好了之后检查是否安装成功，打开&quot;Git Bash Here&quot;，这个是刚刚安装的git程序的一个交互界面 。如下图，出现这种结果就表明安装成功。 (4)安装hexo&nbsp;&nbsp;&nbsp;&nbsp;安装hexo之前需要安装git和node.js，因此前面那两个是准备工作。安装hexo的命令如下：npm install -g hexo-cli // g是generate的意思然后使用hexo命令检查Notice：可以发现会有一个提示，不过不用管，因为它是针对Mac的，对于windows可以忽略，不会对后面有影响。此时切换一个目录，这个目录存放你的博客内容，列入你想把存放博客的文件夹放在version这个文件夹下。那就切换到这个文件夹下。使用hexo init blog用于初始化这个目录，这条命令时候，会发现在出现blog文件夹，里面有很多内容。之后切换到这个blog目录中，并安装它最后启动它：hexo s （hexo generate）若此时在浏览器中不能显示，那么更改这个端口如需显示效果，那么此时在浏览器中输入http://localhost:3600/三、更换主题&nbsp;&nbsp;&nbsp;&nbsp;更换主题之前先清理缓存，使用如下命令清除缓存以及download新的主题：Hexo cleanGit clone https://github.com/litten/hexo-theme-yilia.git theme/yilia （本人使用的主题，如果想切换其它主题可以网上搜索）此时可以看到在/blog/themes文件夹下多了一个yilia文件夹。要想使用这个主题，必须更新主题。在配置文件中修改主题这个选项。修改完成之后，生成并启动hexoHexo gHexo s四、发布到github上(1) 在github上创建一个仓库，名字叫XXX.github.io（XXX为github的用户名），如下图：(2) 注册好了之后，将他们部署到github上，此时需要修改一下配置文件，在blog目录下有一个配置文件 _config.yml，打开文件修改这些内容：(3)弄好了之后，进行部署，使用下面的命令进行部署，不过在部署之前需要安装一个扩展：npm install hexo-deployer-git –savehexo d （部署）部署完成之后，可以在github上看得很多文件，此时访问博客时可以通过http://XXX.github.io五、图片插入问题&nbsp;&nbsp;&nbsp;&nbsp;细心的同学会发现，发布的文章只有文字，而不能正确的显示图片，此时需要安装一个插件。npm install hexo-asset-image –save （安装可以插入图片的插件）hexo new “Linux下多个C++文件的链接编译“ （创建一个Linux下多个C++文件的链接编译.md的文件）&nbsp;&nbsp;&nbsp;&nbsp;此时会发现，在/blog/source/_posts文件夹下，不仅多出了一个 XXX.md的文件，还多了一个XXX文件夹，这个文件夹用于你需要存放的图片，如下图，将图片安装顺序起一个名字（这是为了使用方便），将图片放入到XXX这个文件夹下。然后打开XXX.md这个文件，将文字部分不变，将图片部分替换为：这样的格式，（XXX表示这个文件，n表示第几张图片，也就是要插入哪一张图片）六、修改头像问题(1)在选中的那个主题，这里是yilia主题下的source/img中放入你要上传的头像(2)然后在主题下的_config.yml配置文件做如下修改，将avatar添加一个相对地址(头像的地址)。也可以添加“”(3)查看显示情况：hexo cleanHexo s -p 3600 (本地可以显示)Hexo d （外链接不能正常显示）(4)解决外链接不能显示的方法在主题下的layout/_partial/left-col.ejs做如下修改：第6行添加一个show，使其正常显示。七、折叠文章的内容(部分显示)(1)首先在你要发布的文章中选择一个需要折叠的位置，这个文件是存放你要发布的文章的内容文件，这里我们选择在只显示一个小标题内容后折叠，折叠只需添加点评：&nbsp;&nbsp;&nbsp;&nbsp;这样做之后确实可以达到折叠的效果，但是效果不好，因为它和展开全文重复了，因此这里做进一步的优化(2)修改配置文件&nbsp;&nbsp;&nbsp;&nbsp;将对应主题(这里是yilia主题)下的_config.yml文件做如下修改：八、开通打赏功能(1)将个人的支付宝和微信的图片放在主题下的的图片保存库中。这里是保存在/yilia/source/img下。(2)修改yilia主题的配置文件，如下图：显示如下图所示：九、站点统计功能1.获取代码&nbsp;&nbsp;&nbsp;&nbsp;首先打开网站http://www.amazingcounters.com/进入网站注册账号，然后选择你网站上显示访客数量的样式。一直到最后会有一个复制代码的过程，把代码复制下来进行下一步操作。2.添加代码到主题中&nbsp;&nbsp;&nbsp;&nbsp;为了方便的开启或者关闭访客数量统计功能我们可以在主题的配置文_config.yml里面添加一个变量，counter: true当改为false时即关闭了访客统计功能。在\\hexo\\themes\\yilia\\layout_partial文件夹下新建一个counter.ejs文件，并将在前面复制到的代码粘帖在这个里面。如果想设置访客人数的显示的样式可以在这里略作修改。接下来打开\\hexo\\themes\\yilia\\layout_partial文件夹下的left-col.ejs文件，找到如下代码将下面的代码添加到这个div标签中至此，就已经添加好了统计访客并在主页显示的功能了。十、添加网易云音乐功能(1)首先登陆网易云音乐主页http://music.163.com/，没有账号的可以注册一个，有账号的直接登陆。(2)创建一个歌单，然后把喜欢的歌曲放入歌单里面(注意：只放入没有版权的歌曲)，创建的歌单的名字为：好听的歌曲然后点击那个歌单，如下图，会有一个生成外链播放器的功能，点击进去，会产生一个代码。复制文本框里面的HTML代码。(3)打开blog/themes/yilia/layout/_partial/left-col.ejs。将刚复制的代码做如下放置。红线部分为待放置的代码。十一、左侧边栏的“所有文章”&nbsp;&nbsp;&nbsp;&nbsp;这其实是一个缺失模块，点击之后会有提示教你怎么做。(1)在/blog目录下执行这个命令：npm I hexo-generator-json-content –save(2)在blog目录下的_config.yml配置文件做如下修改：添加红线部分内容。十二、左侧边栏的“随笔”功能&nbsp;&nbsp;&nbsp;&nbsp;随笔在这里其实就是文章的一个tag（标签），如果想把文章作为随笔的话，可以在文章的首部写一个tags为“随笔”的标签。如下图所示：一开始tags是没有东西的，现在添加如下所示。（注意：“-”和“随笔”之间有一个空格）十三、网站加载速度优化手段：代码压缩技术：&nbsp;&nbsp;&nbsp;&nbsp;目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp 插件。hexo-all-minifier 使用比较简单，也可以压缩图片，不过对文章缩进不支持。如果您对文章缩进有要求，可以暂时使用 gulp 压缩手段。1.hexo-all-minifier 插件的使用第一步：安装插件npm install hexo-all-minifier –save第二步：压缩博文，如下图在压缩博文glup 使用方法Hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp –save在blog目录下，新建 gulpfile.js 并填入以下内容：var gulp = require(‘gulp’);var minifycss = require(‘gulp-minify-css’);var uglify = require(‘gulp-uglify’);var htmlmin = require(‘gulp-htmlmin’);var htmlclean = require(‘gulp-htmlclean’);// 压缩 public 目录 cssgulp.task(‘minify-css’, function() {return gulp.src(‘./public//*.css’).pipe(minifycss()).pipe(gulp.dest(‘./public’));});// 压缩 public 目录 htmlgulp.task(‘minify-html’, function() {return gulp.src(‘./public//.html’).pipe(htmlclean()).pipe(htmlmin({removeComments: true,minifyJS: true,minifyCSS: true,minifyURLs: true,})).pipe(gulp.dest(‘./public’))});// 压缩 public/js 目录 jsgulp.task(‘minify-js’, function() {return gulp.src(‘./public/**/.js’).pipe(uglify()).pipe(gulp.dest(‘./public’));});// 执行 gulp 命令时执行的任务gulp.task(‘default’, [‘minify-html’,’minify-css’,’minify-js’]);&nbsp;&nbsp;&nbsp;&nbsp;生成博文时执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。十四、域名和github pages绑定(1)首先申请一个域名，我是在腾讯云上面申请的，地址：https://console.cloud.tencent.com/192.30.252.153和192.30.252.154两个IP为github服务器上的IP，dingwenjin.github.io为github博客的一个域名，图片上dingwenjin.github.io后面还有一个“.”，这个是自动添加的，不需要管。@为直接映射，www是指需要添加www才能访问，添加两个就是为了添加www和不添加www都可以访问。(2) 在/blog/source/下新建一个文件，文件名叫做CNAME，里面添加的内容为你申请的域名，域名中不要http://www.此时可以直接通过域名访问了。我这里添加的是dingwenjin.cn。十五、添加评论系统&nbsp;&nbsp;&nbsp;&nbsp;本文章添加的友言评论系统。首先需要在“友言”官网上注册一个账号。注册完毕之后会有相应的代码的用户ID。这两个东西是需要在后续用到的。(1)添加刚刚复制的那些代码&nbsp;&nbsp;&nbsp;&nbsp;这里使用的是yilia主题。我们首先在文件夹hexo\\themes\\yilia\\layout_partial\\post\\下建立一个uyan.ejs文件，并将刚刚的代码拷贝到里面保存下来。(2)修改hexo\\themes\\yilia\\layout_partial\\article.ejs配置文件&nbsp;&nbsp;&nbsp;&nbsp;打开上面的配置文件，并找到这行代码：&lt;% if (!index &amp;&amp; post.comments){ %&gt;，你会看到下面会默认很多评论系统没有开启，此时你需要添加如下代码到刚刚找到那行代码的下面：&lt;% if (theme.uyan){ %&gt;&lt;%- partial(‘post/uyan’, {key: post.slug,title: post.title,url: config.url+url_for(post.path)}) %&gt;&lt;% } %&gt;(3)修改yilia主题配置文件(hexo\\themes\\yilia_config.yml)&nbsp;&nbsp;&nbsp;&nbsp;打开配置文件，并找到一行空白处，按照下面格式添加你的友言ID：uyan: ‘你的友言ID’ //注意：后有一个空格，这个是默认的。总结：以上步骤基本可以搞定你的评论系统了。只需要重新编译运行就好了。Hexo cleanHexo gHexo s -p 3600 //这里修改端口号为3600，因为默认的4000端口可能被占用。可以发现本地评论可以成功问题：上述只能解决本地评论问题。将上述修改上传你的github上，你会惊讶的发现你刚刚添加的评论系统在页面上没有显示。原因是因为github上用的是https协议进行传输的。他会阻塞http的加载，也就是无法加载友言的那个js文件。最终造成这一结果的原因是友言不支持https。本文的解决方案是更改域名。这样就不在使用https协议进行传输了。而是转到http协议进行传输。(1)如果按照十四步操作的同志，再不有这种问题了。(2)要是跳过了十四步操作的同志，请你添加十四步操作。这样就可以使用评论系统了。温馨解答：(1)一些常用命令：Hexo clean 清除缓存Hexo new “postName” 新建文章Hexo new page “pageName” 新建页面Hexo g 生成静态页面至public目录Hexo s 开启浏览访问端口Hexo d 将.deploy目录部署到github上Hexo help 查看帮助Hexo version 查看版本Hexo g -d //直接生成静态页面至public并部署到GitHub上(2)当使用命令启动hexo服务器时，在浏览器中键入默认的4000端口没有反应，该怎么办？如:http://localhost:4000/解答：此时可能是该端口被其它应用占用了，只需将端口号修改一下，比如下改为3600hexo s -p 3600(3)访问域名出现404问题：原因是仓库名和用户名不一致。","comments":true,"tags":[]},{"title":"子集和问题","date":"2018-01-17T08:18:37.000Z","path":"2018/01/17/子集和问题/","text":"各种类型的子集和问题一、集合中没有重复元素(1)子集和的种类问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于给定的集合和给定的一个和sum，从集合中选取元素得到子集，使得子集的和等于给定的sum，求有多少种组合的方式。思路解析：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此种问题与找币问题一样。采用动态规划的方式解决这一问题。对于每个集合中元素，都有两种方式：选择和不选择。用dp[i]表示子集和为i的组合个数，可知dp[0]为1，因此子集和为0的子集只有空集一个。核心代码：123456789void dfs(int n,int sum)&#123; vector&lt;int&gt; dp(sum+1,0); //初始都为0 int i,j; dp[0]=1; //子集和为0的时候组合为1 for(i=0;i&amp;lt;n;i++) //集合中每个元素有选择和不选择两种方式 for(j=sum;j&amp;gt;=v[i];j++) //内层循环应该是从sum开始递减到v[i],这样确保集合中元素只使用一次；如果从v[i]递增到sum，那么集合中的每个元素可以使用无限多个 dp[j]+=dp[j-v[i]]; //选择v[i]和不选择v[i] cout&lt;&lt;dp[sum]&lt;&lt;endl;&#125; (2)列出子集和的各种方案问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于给定的集合和给定的一个和sum，从集合中选取元素得到子集，使得子集的和等于给定的sum，打印每个符合要求的子集。思路解析：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里采用回溯+递归的方式，采用一个容器保存原始的集合，一个容器保存结果集合。对于原始集合，如果集合中的元素&lt;=sum时，将集合中的元素放入到结果集合，当添加后的的子集和大于预定的值时，那么此时将最后一个添加的踢出结果集合，并继续迭代。核心代码：12345678910111213void dfs(int n, int sum, vector&lt;int&gt;&amp; v, int start) &#123; if(sum == 0) &#123; for(int i = 0; i&amp;lt;v.size(); i++) &#123; i == 0 ? cout &lt;&lt; v[i] : cout &lt;&lt; &quot; &quot; &lt;&lt; v[i]; //i等于0输出v[i],否则先输出空格，后输出v[i] &#125; cout &lt;&lt; endl; &#125; for(int i = start; i &lt;= n &amp;&amp; origin[i] &lt;= sum; i++) &#123; //首先满足下标不越界，同时所选的子集中的元素应该小于等于sum v.push_back(origin[i]); //选定一个元素 dfs(n, sum - origin[i], v, i + 1); //通过sum-origin[i]来进一步的判定这个元素是否可选，如果当它的结果小于0时，它就不满足for循环中的循环条件，就会回退 v.pop_back(); //踢出不符合的元素 &#125;&#125; (3)打印子集个数确定的子集和方案&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与问题二相似，但是需要确保每种子集和的子集中元素个数为给定的个数12345678910111213void dfs(int n, int sum, vector&lt;int&gt;&amp; v, int start) &#123; if(sum == 0 &amp;&amp; v.size()==count_num) &#123; for (int i = 0; i&amp;lt;v.size(); i++) &#123; i == 0 ? cout &lt;&lt; v[i] : cout &lt;&lt; &quot; &quot; &lt;&lt; v[i]; //i等于0输出v[i],否则先输出空格，后输出v[i] &#125; cout &lt;&lt; endl; &#125; for(int i = start; i &lt;= n &amp;&amp; origin[i] &lt;= sum; i++) &#123; //首先满足下标不越界，同时所选的子集中的元素应该小于等于sum v.push_back(origin[i]); //选定一个元素 dfs(n, sum - origin[i], v, i + 1); //通过sum-origin[i]来进一步的判定这个元素是否可选，如果当它的结果小于0时，它就不满足for循环中的循环条件，就会回退 v.pop_back(); //踢出不符合的元素 &#125;&#125; (4)子集允许重复元素，也就是每个元素可以在同一组合中多次出现，但是这种重复元素是同一个位置上的元素多次使用 1234567891011void dfs(vector&lt;int&gt; &amp;candidates, int start, vector&lt;int&gt; &amp;tmp, int sum) &#123; if (sum == 0) &#123; copy(tmp.begin(), tmp.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; &#125; for (int i = start; i&lt;candidates.size() &amp;&amp; candidates[i] &lt;= sum; i++) &#123; tmp.push_back(candidates[i]); dfs(candidates, i, tmp, sum - candidates[i]); //这里的i并没有自增，因为同一个位置的元素可以被多次使用 tmp.pop_back(); &#125;&#125; 二、集合中有重复元素(1)子集中中允许重复元素，但是这种重复来自子集内部的原有的重复，而不是同一个位置元素的多次使用12345678910111213141516171819void dfs(vector&lt;int&gt; &amp;num, int n, int start, int sum, vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt; &amp;tmp) &#123; if (sum == 0) &#123; bool is_unique = true; for (int j = 0; j&lt;result.size(); j++) &#123; //这一步是为了去掉重复组合问题 if (result[j] == tmp) &#123; is_unique = false; break; &#125; &#125; if (is_unique) result.push_back(tmp); &#125; for (int i = start; i &lt;= n &amp;&amp; num[i] &lt;= sum; i++) &#123; //从下标从0~n-1中的元素选取，需保证去得的数要小于target tmp.push_back(num[i]); //将符合的元素先放进临时容器 dfs(num, n, i + 1, sum - num[i], result, tmp); //将target的值减去放入容器的元素的值 tmp.pop_back(); //还原现场 &#125;&#125;","comments":true,"tags":[]},{"title":"迷宫问题","date":"2018-01-16T15:07:58.000Z","path":"2018/01/16/迷宫问题/","text":"回溯法解决迷宫问题一、问题描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个迷宫，如果能够走出这个迷宫，那就寻找一条走出这个迷宫的最短路径，否则不能走出这个迷宫。迷宫是一个方形体，起点为迷宫的左上角，终点为迷宫的右下角。每次都可以往四个不同的方向走，但是不能超过这个迷宫的范围。如果在行走的过程中遇到了障碍物，那么这个方向将不能继续行进，此时将需要选择其它方向。二、思路解析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;迷宫中1表示有路可走，0表示有障碍物。行走的方向可以是上下左右，用一个二维的容器存放迷宫(0,1，其中0表示障碍物，1表示路段可走)；用一个一维容器存放临时的可行方案；用一个一维容器存放最佳的可行方案。每次遇到一个可行方案的时候，将这个可行的方案与最佳的方案对比，如果这个可行的方案比最佳的方案好，那么就将这个可行的方案拷贝给这个最佳的方案。而每个方案的形成需要返回的试探，如果这个方向没有障碍物，那么就走这个方向，否则回退到上一步，并从新选择其它的方向。每次选中一个可行的路径，将这个路径的坐标放进临时容器，回退的时候(也就是此路不通)，将这个坐标踢出这个临时容器。直到坐标到达迷宫的右下角。这里会有一个问题，那就是行走的过程中可能会形成一个环，这就会导致永远也走不出这个迷宫的出口。为了解决这个问题，这里给出的解决方案是每次选择一个可行的行走路径时，将其设置为障碍点，而每次回退的时候，将它恢复为原来的状态。这样就可以避免环形路径。三、核心代码1234567891011121314151617void backtrace(int x,int y) &#123; mate[x][y] = 0; //走的路将不再重复去走 tmp_path.push_back(&#123; x,y &#125;); if(x==M-1 &amp;&amp; y==N-1) if(best_path.empty() || tmp_path.size() &lt; best_path.size()) best_path = tmp_path; if(x - 1 &gt;= 0 &amp;&amp; mate[x - 1][y] == 1) //向上走 backtrace(x - 1, y); if(x + 1 &lt; M &amp;&amp; mate[x + 1][y] == 1) //向下走 backtrace(x + 1, y); if(y - 1 &gt;= 0 &amp;&amp; mate[x][y - 1] == 1) //向左走 backtrace(x, y - 1); if(y + 1 &lt; N &amp;&amp; mate[x][y + 1] == 1) //向右走 backtrace(x, y + 1); mate[x][y] = 1; //恢复现场 tmp_path.pop_back(); //弹出不能走的结点&#125; 四、结果截图 五、完整源码地址：https://github.com/dingwenjin/C-/blob/master/mate.cpp","comments":true,"tags":[]},{"title":"用户自定义unordered_map的key值","date":"2018-01-14T02:11:49.000Z","path":"2018/01/14/用户自定义unordered-map的key值/","text":"解决一个域不唯一标识一个数据节点问题本节的重点主要是讲解unordered_map中用户自定义key值的问题。一、unordered_map介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unordered_map是C++中一个重要的数据结构，它是以键值对(key-value)的方式存储数据项(key值时唯一的)，通过对key值计算hash得到一个唯一的密钥；每次查找key值所在的数据项时，就对待查找的key进行hash得到一个密钥，然后与容器中每个key的密钥对比，要是能找到这个密钥，说明这两个key值是一样的，也就是说这个数据项存在容器中。因此它的查找速度非常快，可以达到常数级别。二、问题的引入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在模拟客户端-服务器数据访问时，想测试一下不同替换算法的命中率情况。于是在论文中找到了一个网址，并下载了很多trace。这些trace都是用户的真实访问情况。这个trace包括这几个数据域：文件名、数据块的逻辑地址、数据块大小、访问属性(读/写)和时间戳。trace显示的情况来看，数据是随机访问的。由于一个trace文件有几百万条记录。考虑到检索的速度，于是使用unordered_map这个结构。它可以有效的减少数据的检索时间。但是单一的文件名或者数据块的逻辑地址是不能唯一确定这个文件的数据块是否存在的。因此默认的常规key就不适合这种情况(常规的key只有一个域就可以唯一确定一个记录)。因此想着自定义一个key，它是一个结构类型，包括多个域。三、思路&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先自定义key，这个类型是一个结构类型。然后再定义一个hash函数，主要是计算每个key的hash值。然后定义一个比较函数，这个比较函数是一个仿函数。主要的功能是判定两个key的各个数据域是否相等。相等返回真，不相等返回假。最后定义容器。主要结构如下：12345678910111213141516171819202122232425struct IO_Record &#123; //value的域 uint32_t Size; //逻辑块大小 uint16_t hit_count; //命中率&#125;;struct Link_Node &#123; //key的域 uint16_t ASU; //文件名 uint32_t LBA; //文件的逻辑块地址&#125;;struct HashFunc &#123; //hash函数，对自定义的key值进行加密，这里使用或和移位操作可以降低hash冲突的概率 size_t operator()(const Link_Node &amp;key) const &#123; using std::size_t; using std::hash; return hash&lt;uint16_t&gt;()(key.ASU) ^ hash&lt;uint32_t&gt;()(key.LBA) &lt;&lt; 1)) &gt;&gt; 1); &#125;&#125;;struct cmp &#123; //这是一个比较函数，用于比较key是否一样 bool operator()(const Link_Node &amp;n1, const Link_Node &amp;n2) const &#123; return n1.ASU == n2.ASU &amp;&amp; n1.LBA == n2.LBA; &#125;&#125;;unordered_map&lt;Link_Node, IO_Record*, HashFunc, cmp&gt; check_request; //定义一个容器 四、结果截图 五、源码分享&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完整的程序已经上传到github上了，如果有需要的同志，可以自行下载：https://github.com/dingwenjin/C-/blob/master/unordered_map.cpp","comments":true,"tags":[]},{"title":"最长公共子序列","date":"2018-01-03T11:28:30.000Z","path":"2018/01/03/最长公共子序列/","text":"来源：牛客网链接：https://www.nowcoder.com/questionTerminal/b1112516673e463c9ed8943ae96e53f6给出两个字符串（可能包含空格）,找出其中最长的公共连续子串,输出其长度。输入描述:输入为两行字符串（可能包含空格），长度均小于等于50.输出描述:输出为一个整数，表示最长公共连续子串的长度。示例：输入abcdeabgde输出2解题思想：&nbsp;&nbsp;&nbsp;&nbsp;创建一张二维表，本来这张表是用来存储字符A[i]和B[j]是否相等然后将表中(i,j)位置置为1。遍历结束后，计算所有的对角线上连续1的个数，取最大值就是结果。但是现在，换种方法，遍历的同时，计算当前斜对角的值，然后用一个变量res记录最大的值即可。&nbsp;&nbsp;&nbsp;&nbsp;它的公式为：如果A[i - 1] == B[j - 1]，那么dp[i][j] = dp[i - 1][j - 1] + 1;其中dp[0][…]和dp[…][0]都是0，这是初始状态。例子：字符串A：abcde字符串B：abgde表11 0 0 0 00 1 0 0 00 0 0 0 00 0 0 1 00 0 0 0 1这个不可以直接得到结果，需要再遍历一次计算。表20 0 0 0 0 00 1 0 0 0 00 0 2 0 0 00 0 0 0 0 00 0 0 0 1 00 0 0 0 0 2这个可以直接得到结果，不需要再遍历一次计算。1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void deal(string s1, string s2) &#123; int i, j, len1 = s1.size(), len2 = s2.size(), max_len = 0; vector&lt;vector&lt;int&gt;&gt; dp(len1+1,vector&lt;int&gt;(len2+1,0)); for(i = 1; i &lt;= len1; i++)&#123; for(j = 1; j &lt;= len2; j++)&#123; if(s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; if(dp[i][j] &gt; max_len) max_len = dp[i][j]; &#125; &#125; cout &lt;&lt; max_len &lt;&lt; endl;&#125;int main() &#123; string s1, s2; while(getline(cin, s1)) &#123; getline(cin, s2); deal(s1, s2); &#125; system(&quot;pause&quot;); return 0;&#125;","comments":true,"tags":[]},{"title":"一棵开花的树","date":"2018-01-03T06:32:37.000Z","path":"2018/01/03/一棵开花的树/","text":"作者：席慕容如何让你遇见我在我最美丽的时刻为这我已在佛前求了五百年求佛让我们结一段尘缘佛於是把我化做一棵树长在你必经的路旁阳光下慎重地开满了花朵朵都是我前世的盼望当你走近请你细听那颤抖的叶是我等待的热情而当你终於无视地走过在你身後落了一地的朋友啊那不是花瓣那是我凋零的心","comments":true,"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux下多个C-文件链接编译","date":"2018-01-01T15:20:24.000Z","path":"2018/01/01/Linux下多个C-文件链接编译/","text":"一、首先在C++文件中创建两个文件夹，一个是myinclude，另一个是src。这里是大数相乘的程序，myinclude中是头文件(仅包含程序体)和它的源文件(实现部分)，src包含主函数。整体的目录结构如下：Myinclude下的头文件如下：12345678910111213/************************************************************************ &gt; File Name: big_data_multi.h &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:42:10 PM PST ************************************************************************/#ifndef _BIG_DATA_MULTI_HEAD_H#define _BIG_DATA_MULTI_HEAD_H#include &lt;string&gt;using std::string;void big_data_multi(string,string);#endif Myinclude下的源文件如下：123456789101112131415161718192021222324252627282930313233/************************************************************************* &gt; File Name: big_data_multi.cpp &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:44:38 PM PST ************************************************************************/#include &quot;big_data_multi_head.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;void big_data_multi(string s1,string s2) &#123; int len1=s1.size(),len2=s2.size(),i,j,carry=0; string result(len1+len2,&apos;0&apos;); reverse(s1.begin(),s1.end()); reverse(s2.begin(),s2.end()); for(i=0;i&lt;len1;i++)&#123; for(j=0;j&lt;len2;j++)&#123; carry=(s1[i]-&apos;0&apos;)*(s2[j]-&apos;0&apos;)+result[i+j]-&apos;0&apos;; result[i+j]=carry%10+&apos;0&apos;; carry/=10; &#125; if(carry) result[i+len2]=carry%10+&apos;0&apos;; carry=0; &#125; reverse(result.begin(),result.end()); if(result[0]==&apos;0&apos;) cout&lt;&lt;result.substr(1)&lt;&lt;endl; else cout&lt;&lt;result&lt;&lt;endl;&#125; src目录下的主文件内容如下：123456789101112131415161718/************************************************************************* &gt; File Name: big_data_multi.cpp &gt; Author: DWJ &gt; Mail: &gt; Created Time: Thu 21 Dec 2017 06:44:38 PM PST ************************************************************************/#include &quot;../myinclude/big_data_multi_head.h&quot;;#include &lt;iostream&gt;#include &lt;string&gt;using std::string;using std::cin;int main(int argc,char** argv)&#123; string s1,s2; while(cin&gt;&gt;s1&gt;&gt;s2) big_data_multi(s1,s2); return 0;&#125; 方式一：编译的过程如下：&nbsp;&nbsp;首先对big_data_multi_head.cpp文件进行编译，因为不事先编译这个文件，而直接编译主文件的话就会出错，出错原因是没有找到主文件调用的函数体。编译后的结果如下： &nbsp;&nbsp;然后对主文件进行编译，形成可执行的main文件： &nbsp;&nbsp;最后执行main文件： 方式二：编译的过程如下：&nbsp;&nbsp;首先对big_data_multi_head.cpp文件进行编译，因为不事先编译这个文件，而直接编译主文件的话就会出错，出错原因是没有找到主文件调用的函数体。编译后的结果如下： &nbsp;&nbsp;然后对主文件进行编译，形成可执行的main文件： &nbsp;&nbsp;最后执行main文件：","comments":true,"tags":[]},{"title":"Python 置筛子结果","date":"2018-01-01T13:32:05.000Z","path":"2018/01/01/Python-置筛子结果/","text":"python程序模拟置筛子结果import pygalfrom random import randintfrom pylab import *mpl.rcParams[‘font.sans-serif’] = [‘SimHei’] #解决中文字体class Die():&nbsp;&nbsp;&nbsp;&nbsp;def init(self,num_sides=6):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.num_sides = num_sides&nbsp;&nbsp;&nbsp;&nbsp;def roll(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return randint(1,self.num_sides+1)def rolling_result(die):&nbsp;&nbsp;&nbsp;&nbsp;results = []&nbsp;&nbsp;&nbsp;&nbsp;for roll_num in range(100000):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = die.roll()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results.append(result)&nbsp;&nbsp;&nbsp;&nbsp;return resultsdef sides_frequency(die,results):&nbsp;&nbsp;&nbsp;&nbsp;frequencies = []&nbsp;&nbsp;&nbsp;&nbsp;for value in range(1,die.num_sides+1):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frequency = results.count(value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frequencies.append(frequency)&nbsp;&nbsp;&nbsp;&nbsp;return frequenciesdef drawing(frequencies):&nbsp;&nbsp;&nbsp;&nbsp;hlist = pygal.Bar()&nbsp;&nbsp;&nbsp;&nbsp;hlist.title = “置骰子10万次各个点数频率分布结果图”&nbsp;&nbsp;&nbsp;&nbsp;hlist.x_labels = [‘1’,’2’,’3’,’4’,’5’,’6’]&nbsp;&nbsp;&nbsp;&nbsp;hlist.x_title = “骰子的各个点数”&nbsp;&nbsp;&nbsp;&nbsp;hlist.y_title = “频率分布”&nbsp;&nbsp;&nbsp;&nbsp;hlist.add(‘D6’,frequencies)&nbsp;&nbsp;&nbsp;&nbsp;hlist.render_to_file(‘die_visual_svg’) #生成def main():&nbsp;&nbsp;&nbsp;&nbsp;die = Die()&nbsp;&nbsp;&nbsp;&nbsp;results = rolling_result(die)&nbsp;&nbsp;&nbsp;&nbsp;frequencies = sides_frequency(die,results)&nbsp;&nbsp;&nbsp;&nbsp;drawing(frequencies)if name == ‘main‘:&nbsp;&nbsp;&nbsp;&nbsp;main()","comments":true,"tags":[]}]